/*
  Created by Fabrizio Di Vittorio (fdivitto2013@gmail.com) - <http://www.fabgl.com>
  Copyright (c) 2019-2020 Fabrizio Di Vittorio.
  All rights reserved.

  This file is part of FabGL Library.

  FabGL is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  FabGL is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with FabGL.  If not, see <http://www.gnu.org/licenses/>.
 */


#pragma once



/**
 * @file
 *
 * @brief This file contains fabgl::Keyboard definition.
 */


#include "freertos/FreeRTOS.h"

#include "fabglconf.h"
#include "comdrivers/ps2device.h"


namespace fabgl {




/**
 * @brief Associates scancode to virtualkey.
 */
struct VirtualKeyDef {
  uint8_t      scancode;    /**< Raw scancode received from the Keyboard device */
  VirtualKey   virtualKey;  /**< Real virtualkey (non shifted) associated to the scancode */
};


/**
 * @brief Associates a virtualkey and various shift states (ctrl, alt, etc..) to another virtualkey.
 */
struct AltVirtualKeyDef {
  VirtualKey reqVirtualKey; /**< Source virtualkey translated using VirtualKeyDef. */
  struct {
    uint8_t ctrl     : 1;   /**< CTRL needs to be down. */
    uint8_t alt      : 1;   /**< ALT needs to be down. */
    uint8_t shift    : 1;   /**< SHIFT needs to be down (OR-ed with capslock). */
    uint8_t capslock : 1;   /**< CAPSLOCK needs to be down (OR-ed with shift). */
    uint8_t numlock  : 1;   /**< NUMLOCK needs to be down. */
  };
  VirtualKey virtualKey;  /**< Generated virtualkey. */
};


/** @brief All in one structure to fully represent a keyboard layout */
struct KeyboardLayout {
  const char *             name;                /**< Layout name. */
  KeyboardLayout const *   inherited;           /**< Inherited layout. Useful to avoid to repeat the same scancode-virtualkeys associations. */
  VirtualKeyDef            scancodeToVK[92];    /**< Direct one-byte-scancode->virtualkey associations. */
  VirtualKeyDef            exScancodeToVK[32];  /**< Direct extended-scancode->virtualkey associations. Extended scancodes begin with 0xE0. */
  AltVirtualKeyDef         alternateVK[64];     /**< Virtualkeys generated by other virtualkeys and shift combinations. */
};


/** @brief Predefined US layout. Often used as inherited layout for other layouts. */
extern const KeyboardLayout USLayout;

/** @brief UK keyboard layout */
extern const KeyboardLayout UKLayout;

/** @brief German keyboard layout */
extern const KeyboardLayout GermanLayout;

/** @brief Italian keyboard layout */
extern const KeyboardLayout ItalianLayout;


struct SupportedLayouts {
  static int count()            { return 4; }
  static char const * * names() {
    static char const * NAMES[] = { "German", "Italian", "UK British", "US English" };
    return NAMES;
  }
  static char const * * shortNames() {
    static char const * SNAMES[] = { "DE", "IT", "UK", "US" };
    return SNAMES;
  }
  static const KeyboardLayout * * layouts() {
    static KeyboardLayout const * LAYOUTS[] = { &GermanLayout, &ItalianLayout, &UKLayout, &USLayout };
    return LAYOUTS;
  }
};


class Keyboard : public PS2Device {

public:

  Keyboard();

  /**
   * @brief Initializes Keyboard specifying CLOCK and DATA GPIOs.
   *
   * A reset command (Keyboard.reset() method) is automatically sent to the keyboard.<br>
   * This method also initializes the PS2Controller to use port 0 only.
   *
   * Because PS/2 ports are handled by the ULP processor, just few GPIO ports are actually usable. They are:
   * GPIO_NUM_2, GPIO_NUM_4, GPIO_NUM_12 (with some limitations), GPIO_NUM_13, GPIO_NUM_14, GPIO_NUM_15, GPIO_NUM_25, GPIO_NUM_26, GPIO_NUM_27, GPIO_NUM_32 and GPIO_NUM_33.
   *
   * @param clkGPIO The GPIO number of Clock line
   * @param dataGPIO The GPIO number of Data line
   * @param generateVirtualKeys If true creates a task which consumes scancodes to produce virtual keys,
   *                            so you can call Keyboard.isVKDown().
   * @param createVKQueue If true creates a task which consunes scancodes and produces virtual keys
   *                      and put them in a queue, so you can call Keyboard.isVKDown(), Keyboard.virtualKeyAvailable()
   *                      and Keyboard.getNextVirtualKey().
   *
   * Example:
   *
   *     // Setup pins GPIO33 for CLK and GPIO32 for DATA
   *     Keyboard.begin(GPIO_NUM_33, GPIO_NUM_32);  // clk, dat
   */
  void begin(gpio_num_t clkGPIO, gpio_num_t dataGPIO, bool generateVirtualKeys = true, bool createVKQueue = true);


  void begin(bool generateVirtualKeys, bool createVKQueue, int PS2Port);


  bool reset();

  bool isKeyboardAvailable() { return m_keyboardAvailable; }

  void setLayout(KeyboardLayout const * layout);

  KeyboardLayout const * getLayout() { return m_layout; }


  bool isVKDown(VirtualKey virtualKey);


  int virtualKeyAvailable();

  VirtualKey getNextVirtualKey(bool * keyDown = nullptr, int timeOutMS = -1);


  void injectVirtualKey(VirtualKey virtualKey, bool keyDown, bool insert = false);


  void emptyVirtualKeyQueue();


  int virtualKeyToASCII(VirtualKey virtualKey);

  /**
   * @brief Gets the number of scancodes available in the queue.
   *
   * Scancodes are always generated but they can be consumed by the scancode-to-virtualkeys task. So, in order to use this
   * method Keyboard.begin() method should be called with generateVirtualKeys = false and createVKQueue = false.<br>
   * Alternatively it is also possible to suspend the conversion task calling Keyboard.suspendVirtualKeyGeneration() method.
   *
   * @return The number of scancodes available to read.
   */
  int scancodeAvailable();

  /**
   * @brief Gets a scancode from the queue.
   *
   * Scancodes are always generated but they can be consumed by the scancode-to-virtualkeys task. So, in order to use this
   * method Keyboard.begin() method should be called with generateVirtualKeys = false and createVKQueue = false.<br>
   * Alternatively it is also possible to suspend the conversion task calling Keyboard.suspendVirtualKeyGeneration() method.
   *
   * @param timeOutMS Timeout in milliseconds. -1 means no timeout (infinite time).
   * @param requestResendOnTimeOut If true and timeout has expired then asks the keyboard to resend the scancode.
   *
   * @return The first scancode of the queue (-1 if no data is available in the timeout period).
   */
  int getNextScancode(int timeOutMS = -1, bool requestResendOnTimeOut = false);

  /**
   * @brief Suspends or resume the virtual key generation task.
   *
   * Use this method to temporarily suspend the scancode to virtual key conversion task. This is useful when
   * scancode are necessary for a limited time.
   *
   * @param value If true conversion task is suspended. If false conversion task is resumed.
   */
  void suspendVirtualKeyGeneration(bool value);

  /**
   * @brief Sets keyboard LEDs status.
   *
   * Use this method to switch-on or off the NUMLOCK, CAPSLOCK and SCROLLLOCK LEDs.
   *
   * @param numLock When true the NUMLOCK LED is switched on.
   * @param capsLock When true the CAPSLOCK LED is switched on.
   * @param scrollLock When true the SCROLLLOCK LED is switched on.
   *
   * @return True if command has been successfully delivered to the keyboard.
   */
  bool setLEDs(bool numLock, bool capsLock, bool scrollLock) { return send_cmdLEDs(numLock, capsLock, scrollLock); }

  /**
   * @brief Gets keyboard LEDs status.
   *
   * Use this method to know the current status of NUMLOCK, CAPSLOCK and SCROLLLOCK LEDs.
   *
   * @param numLock When true the NUMLOCK LED is switched on.
   * @param capsLock When true the CAPSLOCK LED is switched on.
   * @param scrollLock When true the SCROLLLOCK LED is switched on.
   */
  void getLEDs(bool * numLock, bool * capsLock, bool * scrollLock);

  /**
   * @brief Sets typematic rate and delay.
   *
   * If the key is kept pressed down, after repeatDelayMS keyboard starts periodically sending codes with frequency repeatRateMS.
   *
   * @param repeatRateMS Repeat rate in milliseconds (in range 33 ms ... 500 ms).
   * @param repeatDelayMS Repeat delay in milliseconds (in range 250 ms ... 1000 ms, steps of 250 ms).
   *
   * @return True if command has been successfully delivered to the keyboard.
   */
  bool setTypematicRateAndDelay(int repeatRateMS, int repeatDelayMS) { return send_cmdTypematicRateAndDelay(repeatRateMS, repeatDelayMS); }

#if FABGLIB_HAS_VirtualKeyO_STRING
  static char const * virtualKeyToString(VirtualKey virtualKey);
#endif


  //// Delegates ////

  /**
   * @brief Delegate called whenever a new virtual key is decoded from scancodes
   *
   * First parameter is a pointer to the decoded virtual key
   * Second parameter specifies if the key is Down (true) or Up (false)
   */
  Delegate<VirtualKey *, bool> onVirtualKey;


  //// statics (used for common default properties) ////


  /**
   * @brief Stack size of the task that converts scancodes to Virtual Keys Keyboard.
   *
   * Application should change before begin() method.
   *
   * Default value is FABGLIB_DEFAULT_SCODETOVK_TASK_STACK_SIZE (defined in fabglconf.h)
   */
  static int scancodeToVirtualKeyTaskStackSize;



private:

  VirtualKey scancodeToVK(uint8_t scancode, bool isExtended, KeyboardLayout const * layout = nullptr);
  VirtualKey VKtoAlternateVK(VirtualKey in_vk, KeyboardLayout const * layout = nullptr);
  void updateLEDs();
  VirtualKey blockingGetVirtualKey(bool * keyDown);
  static void SCodeToVKConverterTask(void * pvParameters);


  bool                      m_keyboardAvailable;  // self test passed and support for scancode set 2

  // these are valid after a call to generateVirtualKeys(true)
  TaskHandle_t              m_SCodeToVKConverterTask; // Task that converts scancodes to virtual key and populates m_virtualKeyQueue
  QueueHandle_t             m_virtualKeyQueue;

  uint8_t                   m_VKMap[(int)(VK_LAST + 7) / 8];

  KeyboardLayout const *    m_layout;

  bool                      m_CTRL;
  bool                      m_ALT;
  bool                      m_SHIFT;
  bool                      m_CAPSLOCK;
  bool                      m_NUMLOCK;
  bool                      m_SCROLLLOCK;

  // store status of the three LEDs
  bool                      m_numLockLED;
  bool                      m_capsLockLED;
  bool                      m_scrollLockLED;
};





} // end of namespace










